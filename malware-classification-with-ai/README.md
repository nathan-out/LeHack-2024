# AI For Cybersecurity: Applying Machine Learning To Enhance Malware Analysis

*Solomon Sonya*

- [0xSolomonSonya - Twitter](https://twitter.com/0xSolomonSonya)

- [Solomon Sonya - LinkedIn](https://www.linkedin.com/in/solomon-sonya-a6510224/)

## Motivations

- Démystifier l'IA

- Les malwares deviennent de plus en plus sophistiqués

- Les malwares sont de plus en plus développés et distribués grâce à l'IA

- En juin 2024, 2 millions de fichiers malveillants par jour ont été envoyés à VirusTotal, 1.8 millions étaient uniques

- En mars, c'était 1 million

D'après ce constat, il faut une nouvelle approche.

## Définition du problème

Selon l'auteur, aujourd'hui, il manque : 

- Un langage standardisé pour décrire les malwares.

- Un framework robuste.

- Un dataset prêt à être ingéré par une IA.

- Un/plusieurs modèle(s) capable de classer les malwares et détecter les nouvelles souches.

## Machine Learning workflow

1. Définition des objectifs.

2. Collecte de données.

3. Pré-processing (data augmentation, data cleaning, conversion dans un format unique...).

4. Feature engineering (extraction et choix des caractéristiques (*features*) d'intérêt). On utilisera le mot anglais qui est plus significatif que la traduction française.

5. Ingestion des données dans le modèle.

6. Evaluation et calibration, par rapport à la tâche 1.

7. Déploiement du modèle en production avec la mise en place d'un système de reporting et de monitoring.

## Classification multinomial

L'idée est que le modèle puisse ajouter des classes au fur et à mesure du temps. Il peut étendre son nombre de classes si un nouveau malware ne rentre dans aucune des précédentes classes.

Un fichier PE est **très riche** en features. Il faut donc faire un choix, pour cela on peut se baser sur ce que les reversers regardent : 

- Métadonnées.

- Imports/export fonctions et librairies.

- Syscalls.

- Fonctions et opcodes.

- Les *strings* (chaînes de caractère imprimables) contenues dans le PE.

    Les *strings* ne sont pas du tout triviales et peuvent être un marqueur fort pour classer un cryptominer d'un ransomware !

- Event tracing (nécessite une analyse dynamique).

- On pourrait certainement en ajouter d'autres.

## Collecte de features avec VirusTotal

On peut trouver sur ce site des métadonnées, les fonctions et librairies exportées/importées, une analyse des opcodes...

Cependant, nous avons besoin d'énormément de données et cela revient très cher via VirusTotal. Il nous faut développer de nouvelles capacités.

## Extraction de features

Pour chaque binaire, il faut une analyse dynamique pour extraire les features. Cela peut être compliqué à cause des mécanismes d'obfuscation/packing qu'utilisent les développeurs de malware, en plus du défis d'automatiser un tel process. On peut néanmoins utiliser `Remnux`, `Objdump` et **beaucoup** d'autres outils pour tenter d'extraire un maximum d'information et augmenter l'automatisation.

Ensuite, on normalise les données et on les envoie dans notre modèle.

## Premiers résultats

En utilisant un classifieur simple, on peut arriver à environ 85% de précision (on ne rentre pas dans l'explication du recall, du score F1 et de ces autres métriques).

## Choix des modèles

Peut-on faire mieux que 85% ? **Oui**.

On peut combiner un ensemble de classifieurs dit *"faibles"* pour améliorer les résultats (on observe ceci de manière empirique). On va créer un **méta-modèle hétérogène**.

## Seconds résultats

- **Il existe un modèle optimal pour chaque classe de malware !** 

- **Le méta-modèle a une précision de 95%.**

Pour qu'il produise un résultat à partir des classifieurs *"faibles"*, on fait voter chaque sous-modèles.

## Publications

Publication du projet sous le nom [MABEL](https://github.com/mabel-dev/mabel) et du dataset [MABEL dataset](https://github.com/action-ai-institute/MABEL-dataset).
